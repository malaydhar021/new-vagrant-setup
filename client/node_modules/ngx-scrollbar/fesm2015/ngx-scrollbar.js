import { supportsScrollBehavior } from '@angular/cdk/platform';
import { ScrollingModule, CdkScrollable } from '@angular/cdk/scrolling';
import { BreakpointObserver, Breakpoints, LayoutModule } from '@angular/cdk/layout';
import { Directive, ElementRef, Inject, PLATFORM_ID, NgModule, Component, Input, ViewChild, ChangeDetectorRef, ChangeDetectionStrategy, NgZone, forwardRef } from '@angular/core';
import { isPlatformBrowser, DOCUMENT, CommonModule } from '@angular/common';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { from, of, animationFrameScheduler, Subject, Subscription, BehaviorSubject, fromEvent } from 'rxjs';
import { tap, throttleTime, debounceTime, mergeMap, pluck, takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmoothScroll {
    /**
     * @param {?} _platform
     * @param {?} el
     */
    constructor(_platform, el) {
        this._platform = _platform;
        this.view = el.nativeElement;
    }
    /**
     * @private
     * @param {?} left
     * @param {?} top
     * @return {?}
     */
    scrollFunc(left, top) {
        if (supportsScrollBehavior()) {
            this.view.scrollTo({ top, left });
        }
        else {
            this.view.scrollTop = top;
            this.view.scrollLeft = left;
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    scrollTo(options) {
        // Avoid SSR error
        if (isPlatformBrowser(this._platform)) {
            /** @type {?} */
            const scrollFunc = (left, top) => {
                if (supportsScrollBehavior()) {
                    this.view.scrollTo({ top, left });
                }
                else {
                    this.view.scrollTop = top;
                    this.view.scrollLeft = left;
                }
            };
            if (options.duration) {
                /** @type {?} */
                const smoothScrollOptions = {
                    top: options.top,
                    left: options.left,
                    duration: options.duration,
                    easeFunc: options.easeFunc || easeInOutQuad,
                    offsetTop: this.view.scrollTop,
                    offsetLeft: this.view.scrollLeft,
                    scrollFunc
                };
                return from(smoothScroll(smoothScrollOptions));
            }
            this.scrollFunc(options.left, options.top);
        }
        return of();
    }
    /**
     * @param {?} selector
     * @param {?=} offset
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToElement(selector, offset = 0, duration, easeFunc) {
        /** @type {?} */
        const target = this.view.querySelector(selector);
        return target ? this.scrollTo({ left: target.offsetLeft, top: target.offsetTop - offset, duration, easeFunc }) : of();
    }
    /**
     * @param {?} left
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollXTo(left, duration, easeFunc) {
        return this.scrollTo({ left, duration, easeFunc });
    }
    /**
     * @param {?} top
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollYTo(top, duration, easeFunc) {
        return this.scrollTo({ top, duration, easeFunc });
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToTop(duration, easeFunc) {
        return this.scrollYTo(0, duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToBottom(duration, easeFunc) {
        return this.scrollYTo(this.view.scrollHeight - this.view.clientHeight, duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToRight(duration, easeFunc) {
        return this.scrollXTo(this.view.scrollWidth, duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToLeft(duration, easeFunc) {
        return this.scrollXTo(0, duration, easeFunc);
    }
}
SmoothScroll.decorators = [
    { type: Directive, args: [{
                selector: '[smoothScroll], [smooth-scroll]'
            },] }
];
/** @nocollapse */
SmoothScroll.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef }
];
/**
 * @param {?} options
 * @return {?}
 */
function smoothScroll(options) {
    return new Promise(resolve => {
        /** @type {?} */
        let currentTime = 0;
        /** @type {?} */
        const increment = 10;
        /** @type {?} */
        let valX = options.offsetLeft;
        /** @type {?} */
        let valY = options.offsetTop;
        /** @type {?} */
        const animateScroll = () => {
            // increment the time
            currentTime += increment;
            // find the value with the easing function
            if (typeof options.left !== 'undefined') {
                /** @type {?} */
                const deltaX = options.left - options.offsetLeft;
                valX = options.easeFunc(currentTime, options.offsetLeft, deltaX, options.duration);
            }
            if (typeof options.top !== 'undefined') {
                /** @type {?} */
                const deltaY = options.top - options.offsetTop;
                valY = options.easeFunc(currentTime, options.offsetTop, deltaY, options.duration);
            }
            // scroll to position
            options.scrollFunc(valX, valY);
            // do the animation unless its over
            if (currentTime < options.duration) {
                animationFrameScheduler.schedule(animateScroll);
            }
            else {
                resolve();
            }
        };
        animateScroll();
    });
}
// easing functions http://goo.gl/5HLl8
/**
 * @param {?} t
 * @param {?} b
 * @param {?} c
 * @param {?} d
 * @return {?}
 */
function easeInOutQuad(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
        return (c / 2) * t * t + b;
    }
    t--;
    return (-c / 2) * (t * (t - 2) - 1) + b;
}
/**
 * @param {?} t
 * @param {?} b
 * @param {?} c
 * @param {?} d
 * @return {?}
 */
function easeInCubic(t, b, c, d) {
    /** @type {?} */
    const tc = (t /= d) * t * t;
    return b + c * tc;
}
/**
 * @param {?} t
 * @param {?} b
 * @param {?} c
 * @param {?} d
 * @return {?}
 */
function inOutQuintic(t, b, c, d) {
    /** @type {?} */
    const ts = (t /= d) * t;
    /** @type {?} */
    const tc = ts * t;
    return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmoothScrollModule {
}
SmoothScrollModule.decorators = [
    { type: NgModule, args: [{
                imports: [ScrollingModule],
                declarations: [SmoothScroll],
                exports: [SmoothScroll]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Native scrollbar size is 17px on all browsers,
// This value will be used to push the native scrollbar out of the scroll view to hide them
// An extra 1px is added to hide them properly on Edge browser
/** @type {?} */
const NATIVE_SCROLLBAR_SIZE = '18px';
class NgScrollbar {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _breakpointObserver
     * @param {?} _platform
     */
    constructor(_changeDetectorRef, _breakpointObserver, _platform) {
        this._changeDetectorRef = _changeDetectorRef;
        this._breakpointObserver = _breakpointObserver;
        this._platform = _platform;
        /**
         * Horizontal custom scrollbar
         */
        this.trackX = false;
        /**
         * Vertical custom Scrollbar
         */
        this.trackY = true;
        /**
         * Scrollbar visibility
         */
        this.shown = 'native';
        /**
         * Auto update scrollbars on content changes (Mutation Observer)
         */
        this.autoUpdate = true;
        /**
         * The smooth scroll duration when a scrollbar is clicked
         */
        this.scrollToDuration = 300;
        /**
         * Disable custom scrollbars on specific breakpoints
         */
        this.disableOnBreakpoints = [
            Breakpoints.HandsetLandscape,
            Breakpoints.HandsetPortrait
        ];
        this._disabled = false;
        /**
         * Mutation observer subscription
         */
        this._updateObserverSub$ = Subscription.EMPTY;
        /**
         * CDK breakpoint subscription
         */
        this._breakpointSub$ = Subscription.EMPTY;
        /**
         * Steam that emits when scrollbar thumbnail needs to update (for internal uses)
         */
        this._updateObserver = new Subject();
        this.updateObserver = this._updateObserver.asObservable();
    }
    /**
     * Disable custom scrollbars and switch back to native scrollbars
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} disable
     * @return {?}
     */
    set disabled(disable) {
        disable ? this.disable() : this.enable();
    }
    /**
     * @return {?}
     */
    get hideNativeScrollbars() {
        /** @type {?} */
        const size = this.disabled ? '100%' : `calc(100% + ${NATIVE_SCROLLBAR_SIZE})`;
        return {
            width: this.trackY ? size : '100%',
            height: this.trackX ? size : '100%'
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.view = this.scrollable.getElementRef().nativeElement;
        // Avoid 'expression has changed after it was checked' error when 'disableOnBreakpoints' is set to false
        Promise.resolve().then(() => {
            if (!this.disabled) {
                if (this.disableOnBreakpoints) {
                    // Enable/Disable custom scrollbar on breakpoints (Used to disable scrollbars on mobile phones)
                    this._breakpointSub$ = this._breakpointObserver.observe(this.disableOnBreakpoints).pipe(tap((result) => result.matches ? this.disable() : this.enable())).subscribe();
                }
                else {
                    this.enable();
                }
            }
            // Update state on content changes
            this._updateObserverSub$ = this.updateObserver.pipe(throttleTime(200), tap(() => this._changeDetectorRef.markForCheck())).subscribe();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._breakpointSub$.unsubscribe();
        this._updateObserverSub$.unsubscribe();
        if (this._observer) {
            this._observer.disconnect();
        }
    }
    /**
     * Update scrollbar thumbnail position
     * @return {?}
     */
    update() {
        if (!this.disabled) {
            this._updateObserver.next();
        }
    }
    /**
     * Enable custom scrollbar
     * @return {?}
     */
    enable() {
        if (this.view) {
            this._disabled = false;
            // Update view
            this._changeDetectorRef.markForCheck();
            if (this.autoUpdate && isPlatformBrowser(this._platform)) {
                // Observe content changes
                this._observer = new MutationObserver(() => this.update());
                this._observer.observe(this.view, { subtree: true, childList: true, characterData: true });
            }
        }
    }
    /**
     * Disable custom scrollbar
     * @return {?}
     */
    disable() {
        this._disabled = true;
        if (this._observer) {
            this._observer.disconnect();
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    scrollTo(options) {
        return this.smoothScroll.scrollTo(options);
    }
    /**
     * @param {?} selector
     * @param {?=} offset
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToElement(selector, offset = 0, duration, easeFunc) {
        return this.smoothScroll.scrollToElement(selector, offset, duration, easeFunc);
    }
    /**
     * @param {?} to
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollXTo(to, duration, easeFunc) {
        return this.smoothScroll.scrollXTo(to, duration, easeFunc);
    }
    /**
     * @param {?} to
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollYTo(to, duration, easeFunc) {
        return this.smoothScroll.scrollYTo(to, duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToTop(duration, easeFunc) {
        return this.smoothScroll.scrollToTop(duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToBottom(duration, easeFunc) {
        return this.smoothScroll.scrollToBottom(duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToRight(duration, easeFunc) {
        return this.smoothScroll.scrollToRight(duration, easeFunc);
    }
    /**
     * @param {?=} duration
     * @param {?=} easeFunc
     * @return {?}
     */
    scrollToLeft(duration, easeFunc) {
        return this.smoothScroll.scrollToLeft(duration, easeFunc);
    }
}
NgScrollbar.decorators = [
    { type: Component, args: [{
                selector: 'ng-scrollbar',
                template: "<div class=\"ng-scrollbar-layout ng-scrollbar-x-layout\"\r\n     [class.ng-scrollbar-invert]=\"invertX\">\r\n\r\n  <div class=\"ng-scrollbar-layout ng-scrollbar-y-layout\"\r\n       [class.ng-scrollbar-invert]=\"invertY\">\r\n\r\n    <div class=\"ng-scroll-view-container\">\r\n      <div #view\r\n           cdkScrollable\r\n           smoothScroll\r\n           class=\"ng-scroll-view {{viewClass}}\"\r\n           [ngStyle]=\"hideNativeScrollbars\">\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n\r\n    <ng-scrollbar-y #y\r\n                    *ngIf=\"!disabled && trackY\"\r\n                    [class.ng-scrollbar-visible]=\"shown === 'always' || view.scrollHeight > view.clientHeight\"\r\n                    [barClass]=\"barClass\"\r\n                    [thumbClass]=\"thumbClass\"\r\n                    [scrollToDuration]=\"scrollToDuration\">\r\n    </ng-scrollbar-y>\r\n  </div>\r\n\r\n  <ng-scrollbar-x #x\r\n                  *ngIf=\"!disabled && trackX\"\r\n                  [class.ng-scrollbar-visible]=\"shown === 'always' || view.scrollWidth > view.clientWidth\"\r\n                  [barClass]=\"barClass\"\r\n                  [thumbClass]=\"thumbClass\"\r\n                  [scrollToDuration]=\"scrollToDuration\">\r\n  </ng-scrollbar-x>\r\n\r\n</div>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[attr.trackX]': 'trackX',
                    '[attr.trackY]': 'trackY',
                    '[attr.compact]': 'compact',
                    '[attr.autoHide]': 'shown === "hover"'
                },
                styles: [":host{display:block;overflow:hidden;--scrollbar-color:transparent;--scrollbar-container-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:rgba(0, 0, 0, 0.3);--scrollbar-border-radius:4px;--scrollbar-size:6px;--scrollbar-padding:8px;--scroll-view-margin:0;--scroll-view-color:transparent}:host[trackY=true]>.ng-scrollbar-layout>.ng-scrollbar-layout>.ng-scroll-view-container>.ng-scroll-view{overflow-y:scroll}:host[trackX=true]>.ng-scrollbar-layout>.ng-scrollbar-layout>.ng-scroll-view-container>.ng-scroll-view{overflow-x:scroll}:host>.ng-scrollbar-x-layout{flex-direction:column}:host>.ng-scrollbar-x-layout.ng-scrollbar-invert{flex-direction:column-reverse}:host>.ng-scrollbar-x-layout>.ng-scrollbar-y-layout{flex-direction:row}:host>.ng-scrollbar-x-layout>.ng-scrollbar-y-layout.ng-scrollbar-invert{flex-direction:row-reverse}:host[compact=true]>.ng-scrollbar-x-layout>ng-scrollbar-x{position:absolute;bottom:0}:host[compact=true]>.ng-scrollbar-x-layout.ng-scrollbar-invert>ng-scrollbar-x{top:0;bottom:unset}:host[compact=true]>.ng-scrollbar-x-layout>.ng-scrollbar-y-layout>ng-scrollbar-y{position:absolute;right:0;left:unset}:host[compact=true]>.ng-scrollbar-x-layout>.ng-scrollbar-y-layout.ng-scrollbar-invert>ng-scrollbar-y{right:unset;left:0}:host[autoHide=true]>.ng-scrollbar-layout>.ng-scrollbar-layout>ng-scrollbar-y,:host[autoHide=true]>.ng-scrollbar-layout>ng-scrollbar-x{opacity:0;transition:opacity 120ms ease-out}:host[autoHide=true]:active>.ng-scrollbar-layout>.ng-scrollbar-layout>ng-scrollbar-y,:host[autoHide=true]:active>.ng-scrollbar-layout>ng-scrollbar-x,:host[autoHide=true]:focus>.ng-scrollbar-layout>.ng-scrollbar-layout>ng-scrollbar-y,:host[autoHide=true]:focus>.ng-scrollbar-layout>ng-scrollbar-x,:host[autoHide=true]:hover>.ng-scrollbar-layout>.ng-scrollbar-layout>ng-scrollbar-y,:host[autoHide=true]:hover>.ng-scrollbar-layout>ng-scrollbar-x{opacity:1;transition:opacity 340ms ease-out}.ng-scroll-view,.ng-scrollbar-layout,:host{position:relative;height:100%;width:100%}.ng-scrollbar-layout{display:flex;min-height:0}.ng-scroll-view-container{flex:1;position:relative;overflow:hidden;margin:var(--scroll-view-margin)}.ng-scroll-view{box-sizing:content-box;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--scroll-view-color);-webkit-overflow-scrolling:touch}ng-scrollbar-x,ng-scrollbar-y{display:none;box-sizing:border-box;padding:var(--scrollbar-padding);background:var(--scrollbar-container-color)}ng-scrollbar-x.ng-scrollbar-visible,ng-scrollbar-y.ng-scrollbar-visible{display:block}ng-scrollbar-y{top:0;bottom:0}ng-scrollbar-x{left:0;right:0}::ng-deep ng-scrollbar-y .ng-scrollbar{width:var(--scrollbar-size)}::ng-deep ng-scrollbar-y .ng-scrollbar-thumb{width:100%}::ng-deep ng-scrollbar-x .ng-scrollbar{height:var(--scrollbar-size)}::ng-deep ng-scrollbar-x .ng-scrollbar-thumb{height:100%}::ng-deep .ng-scrollbar{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-color)}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;width:0;height:0;border-radius:inherit;background-color:var(--scrollbar-thumb-color);-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);transition:height ease-out 150ms}::ng-deep .ng-scrollbar-thumb:active,::ng-deep .ng-scrollbar-thumb:hover{background-color:var(--scrollbar-thumb-hover-color)}"]
            }] }
];
/** @nocollapse */
NgScrollbar.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: BreakpointObserver },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgScrollbar.propDecorators = {
    trackX: [{ type: Input }],
    trackY: [{ type: Input }],
    shown: [{ type: Input }],
    autoUpdate: [{ type: Input }],
    viewClass: [{ type: Input }],
    barClass: [{ type: Input }],
    thumbClass: [{ type: Input }],
    scrollToDuration: [{ type: Input }],
    compact: [{ type: Input }],
    invertY: [{ type: Input }],
    invertX: [{ type: Input }],
    disableOnBreakpoints: [{ type: Input }],
    disabled: [{ type: Input, args: ['disabled',] }],
    scrollable: [{ type: ViewChild, args: [CdkScrollable,] }],
    smoothScroll: [{ type: ViewChild, args: [SmoothScroll,] }],
    verticalScrollbar: [{ type: ViewChild, args: ['y', { read: ElementRef },] }],
    horizontalScrollbar: [{ type: ViewChild, args: ['x', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarThumb {
    /**
     * @param {?} _parent
     * @param {?} _platform
     * @param {?} _zone
     */
    constructor(_parent, _platform, _zone) {
        this._parent = _parent;
        this._platform = _platform;
        this._zone = _zone;
        this._minThumbSize = 20;
        this._naturalThumbSize = 0;
        this._thumbSize = 0;
        this._trackMax = 0;
        this._scrollMax = 0;
        this._currPos = 0;
        this._scroll$ = Subscription.EMPTY;
        this._thumbDrag$ = Subscription.EMPTY;
        this._updateObserver$ = Subscription.EMPTY;
        this._state = new BehaviorSubject({
            transform: 'translate3d(0, 0, 0)'
        });
        /**
         * Scrollbar styles
         */
        this.scrollbarStyle = this._state.asObservable();
    }
    /**
     * @return {?}
     */
    get thumbSize() {
        return 0;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Avoid SSR Error
        if (isPlatformBrowser(this._platform)) {
            this._view = this._parent.scrollable.getElementRef().nativeElement;
            // Start view scroll event
            this._scroll$ = this._parent.scrollable.elementScrolled()
                .subscribe(() => this.updateScrollbar());
            // Start scrollbar thumbnail drag events
            this._zone.runOutsideAngular(() => this._thumbDrag$ = this.startThumbEvents().subscribe());
            // Update scrollbar thumbnail size on content changes
            this._updateObserver$ = this._parent.updateObserver.pipe(throttleTime(200), tap(() => this.updateScrollbar()), 
            // Make sure scrollbar thumbnail position is correct after the new content is rendered
            debounceTime(200), tap(() => this.updateScrollbar())).subscribe();
            // Initialize scrollbar
            setTimeout(() => this.updateScrollbar(), 200);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._scroll$.unsubscribe();
        this._thumbDrag$.unsubscribe();
        this._updateObserver$.unsubscribe();
    }
    /**
     * Scrollbar click
     * @param {?} e Mouse event
     * @return {?}
     */
    onScrollbarHolderClick(e) {
    }
    /**
     * Update scrollbar
     * @protected
     * @return {?}
     */
    updateScrollbar() {
    }
    /**
     * Start vertical thumb worker
     * @protected
     * @return {?}
     */
    startThumbEvents() {
        return undefined;
    }
    /**
     * Get scrollbar thumb size
     * @protected
     * @param {?} naturalThumbSize
     * @param {?} scrollMax
     * @return {?}
     */
    scrollBoundaries(naturalThumbSize, scrollMax) {
        return (naturalThumbSize < this._minThumbSize) ? this._minThumbSize : scrollMax ? naturalThumbSize : 0;
    }
    /**
     * @protected
     * @param {?} state
     * @return {?}
     */
    updateState(state) {
        this._state.next(Object.assign({}, this._state.value, state));
    }
}
NgScrollbarThumb.propDecorators = {
    barClass: [{ type: Input }],
    thumbClass: [{ type: Input }],
    scrollToDuration: [{ type: Input }],
    bar: [{ type: ViewChild, args: ['bar',] }],
    thumb: [{ type: ViewChild, args: ['thumb',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarY extends NgScrollbarThumb {
    /**
     * @param {?} _document
     * @param {?} _parent
     * @param {?} _platform
     * @param {?} _zone
     */
    constructor(_document, _parent, _platform, _zone) {
        super(_parent, _platform, _zone);
        this._document = _document;
        this._parent = _parent;
        this._zone = _zone;
    }
    /**
     * Calculate scrollbar thumbnail size
     * @return {?}
     */
    get thumbSize() {
        /** @type {?} */
        const barClientHeight = this.bar.nativeElement.clientHeight;
        /** @type {?} */
        const viewClientHeight = this._view.clientHeight;
        /** @type {?} */
        const viewScrollHeight = this._view.scrollHeight;
        this._naturalThumbSize = barClientHeight / viewScrollHeight * barClientHeight;
        this._scrollMax = viewScrollHeight - viewClientHeight;
        return this.scrollBoundaries(this._naturalThumbSize, this._scrollMax);
    }
    /**
     * Scrollbar click
     * @param {?} e Mouse event
     * @return {?}
     */
    onScrollbarHolderClick(e) {
        if (e.target === e.currentTarget) {
            /** @type {?} */
            const offsetY = e.offsetY - this._naturalThumbSize * .5;
            /** @type {?} */
            const thumbPositionPercentage = offsetY * 100 / this.bar.nativeElement.clientHeight;
            /** @type {?} */
            const value = thumbPositionPercentage * this._view.scrollHeight / 100;
            this._parent.scrollTo((/** @type {?} */ ({ top: value, duration: this.scrollToDuration }))).subscribe();
        }
    }
    /**
     * Update scrollbar
     * @protected
     * @return {?}
     */
    updateScrollbar() {
        this._thumbSize = this.thumb.nativeElement.clientHeight;
        this._trackMax = this.bar.nativeElement.clientHeight - this._thumbSize;
        this._currPos = this._view.scrollTop * this._trackMax / this._scrollMax;
        this._zone.run(() => {
            animationFrameScheduler.schedule(() => this.updateState({
                transform: `translate3d(0, ${this._currPos}px, 0)`,
                height: `${this.thumbSize}px`
            }));
        });
    }
    /**
     * Start vertical thumb worker
     * @protected
     * @return {?}
     */
    startThumbEvents() {
        /** @type {?} */
        const mouseDown$ = fromEvent(this.thumb.nativeElement, 'mousedown');
        /** @type {?} */
        const mouseMove$ = fromEvent(this._document, 'mousemove');
        /** @type {?} */
        const mouseUp$ = fromEvent(this._document, 'mouseup').pipe(tap(() => this._document.onselectstart = null));
        return mouseDown$.pipe(tap(() => {
            this._document.onselectstart = () => false;
            // Initialize trackMax for before start dragging
            this._trackMax = this.bar.nativeElement.clientHeight - this._thumbSize;
        }), pluck('offsetY'), mergeMap((mouseDownOffset) => mouseMove$.pipe(takeUntil(mouseUp$), pluck('clientY'), tap((mouseMoveClient) => {
            /** @type {?} */
            const offsetY = mouseMoveClient - this.bar.nativeElement.getBoundingClientRect().top;
            /** @type {?} */
            const value = this._scrollMax * (offsetY - mouseDownOffset) / this._trackMax;
            this._parent.scrollable.scrollTo({ top: value });
        }))));
    }
}
NgScrollbarY.decorators = [
    { type: Component, args: [{
                selector: 'ng-scrollbar-y',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div #bar class="ng-scrollbar {{barClass}}" (mousedown)="onScrollbarHolderClick($event)">
      <div #thumb class="ng-scrollbar-thumb {{thumbClass}}" [ngStyle]="scrollbarStyle | async"></div>
    </div>
  `
            }] }
];
/** @nocollapse */
NgScrollbarY.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgScrollbar, decorators: [{ type: Inject, args: [forwardRef(() => NgScrollbar),] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarX extends NgScrollbarThumb {
    /**
     * @param {?} _document
     * @param {?} _parent
     * @param {?} _platform
     * @param {?} _dir
     * @param {?} _zone
     */
    constructor(_document, _parent, _platform, _dir, _zone) {
        super(_parent, _platform, _zone);
        this._document = _document;
        this._parent = _parent;
        this._dir = _dir;
        this._zone = _zone;
    }
    /**
     * Calculate scrollbar thumbnail size
     * @return {?}
     */
    get thumbSize() {
        /** @type {?} */
        const barClientWidth = this.bar.nativeElement.clientWidth;
        /** @type {?} */
        const viewClientWidth = this._view.clientWidth;
        /** @type {?} */
        const viewScrollWidth = this._view.scrollWidth;
        this._naturalThumbSize = barClientWidth / viewScrollWidth * barClientWidth;
        this._scrollMax = viewScrollWidth - viewClientWidth;
        return this.scrollBoundaries(this._naturalThumbSize, this._scrollMax);
    }
    /**
     * Scrollbar click
     * @param {?} e Mouse event
     * @return {?}
     */
    onScrollbarHolderClick(e) {
        if (e.target === e.currentTarget) {
            /** @type {?} */
            const offsetX = e.offsetX - this._naturalThumbSize * .5;
            /** @type {?} */
            const thumbPositionPercentage = offsetX * 100 / this.bar.nativeElement.clientWidth;
            /** @type {?} */
            const value = thumbPositionPercentage * this._view.scrollWidth / 100;
            this._parent.scrollTo((/** @type {?} */ ({ left: value, duration: this.scrollToDuration }))).subscribe();
        }
    }
    /**
     * Update scrollbar
     * @protected
     * @return {?}
     */
    updateScrollbar() {
        this._thumbSize = this.thumb.nativeElement.clientWidth;
        this._trackMax = this.bar.nativeElement.clientWidth - this._thumbSize;
        this._currPos = this._view.scrollLeft * this._trackMax / this._scrollMax;
        this._zone.run(() => {
            animationFrameScheduler.schedule(() => this.updateState({
                transform: `translate3d(${this._dir.value === 'rtl' ? this._currPos - this._trackMax : this._currPos}px, 0, 0)`,
                width: `${this.thumbSize}px`
            }));
        });
    }
    /**
     * Start horizontal thumb worker
     * @protected
     * @return {?}
     */
    startThumbEvents() {
        /** @type {?} */
        const mouseDown$ = fromEvent(this.thumb.nativeElement, 'mousedown');
        /** @type {?} */
        const mouseMove$ = fromEvent(this._document, 'mousemove');
        /** @type {?} */
        const mouseUp$ = fromEvent(this._document, 'mouseup').pipe(tap(() => this._document.onselectstart = null));
        return mouseDown$.pipe(tap(() => {
            this._document.onselectstart = () => false;
            // Initialize trackMax for before start dragging
            this._trackMax = this.bar.nativeElement.clientWidth - this._thumbSize;
        }), pluck('offsetX'), mergeMap((mouseDownOffset) => mouseMove$.pipe(takeUntil(mouseUp$), pluck('clientX'), tap((mouseMoveClient) => {
            /** @type {?} */
            const offsetX = mouseMoveClient - this.bar.nativeElement.getBoundingClientRect().left;
            /** @type {?} */
            let value = this._scrollMax * (offsetX - mouseDownOffset) / this._trackMax;
            if (this._dir.value === 'rtl') {
                value = value === 0 ? offsetX - this._trackMax : value;
            }
            this._parent.scrollable.scrollTo({ left: value });
        }))));
    }
}
NgScrollbarX.decorators = [
    { type: Component, args: [{
                selector: 'ng-scrollbar-x',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div #bar class="ng-scrollbar {{barClass}}" (mousedown)="onScrollbarHolderClick($event)">
      <div #thumb class="ng-scrollbar-thumb {{thumbClass}}" [ngStyle]="scrollbarStyle | async"></div>
    </div>
  `
            }] }
];
/** @nocollapse */
NgScrollbarX.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgScrollbar, decorators: [{ type: Inject, args: [forwardRef(() => NgScrollbar),] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: Directionality },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgScrollbarModule {
}
NgScrollbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ScrollingModule,
                    LayoutModule,
                    BidiModule,
                    SmoothScrollModule
                ],
                declarations: [
                    NgScrollbar,
                    NgScrollbarY,
                    NgScrollbarX
                ],
                exports: [
                    NgScrollbar
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgScrollbarModule, NgScrollbar, SmoothScrollModule, smoothScroll, easeInOutQuad, easeInCubic, inOutQuintic, SmoothScroll, NgScrollbarThumb as ɵb, NgScrollbarX as ɵc, NgScrollbarY as ɵa };

//# sourceMappingURL=ngx-scrollbar.js.map